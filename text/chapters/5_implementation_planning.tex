\chapter{Implementation Planning}
This section provides an insight into the high-level technology choices behind the application.
In addition, UML diagrams are provided as an overview of the system.

The created platform is built using the Model-View-Controller \cite{mvc} architectural pattern.
It is split into three major parts:
\begin{itemize}
    \item \textbf{Backend.} Implements all the data-related logic and processing.
    \item \textbf{API.} Is responsible for transferring the data to the frontend and receiving commands from it.
    \item \textbf{Frontend.} Presents the data to the User and accepts his commands.
\end{itemize}


\section{Backend}
Python was chosen as the main language for the Backend part of the application.
It has support for all the needed instruments, such as external processes calls,
file handling, and asynchronous code execution. Moreover, it has a flexible and straightforward
syntax allowing for rapid development.
As this project is mostly IO-driven and most of the processor-heavy operations are offloaded to external processes,
i.e. no thread programming is used, Python's performance limitations\cite{gil} will not have such a drastic effect.

\subsection{Framework Comparison}
Currently, there are 3 well-developed and widely-used WEB frameworks available for Python:

\begin{itemize}
    \item \textbf{FastAPI} \\
    'FastAPI is a modern, fast (high-performance), web framework for building APIs
    with Python, based on standard Python type hints.'~\cite{fastapi}. \\
    This framework provides a lightweight approach to API declaration, without adding almost no overhead.
    It has the best integration with API documentation standards such as
    Open API and API representation tools, e.g. Swagger.

    However, it is relatively new and basic; given the requirements and the fact that
    few additional packages are available - a lot of custom code would have
    to be written on top, which is a disadvantage for this specific project.

    \item \textbf{Django} \\
    Django is a 'batteries-included' framework, in a sense that almost everything -
    from access control and database management to API routing and admin interface,
    is a part of it.\cite{django}
    Additionally, Django offers an extensive ecosystem, including support for RESTful APIs through
    \texttt{django-rest-framework}\cite{drf}, various authentication methods,
    and multiple data transfer protocols. Real-time communication, such as WebSockets and Server-Sent Events,
    is supported via the \texttt{django-channels}\cite{django_channels} package.

    Some of the notable drawbacks include its opinionated design choices and the size of the application,
    as it includes a lot of parts that may not be used.

    \item \textbf{Flask} \\
    Flask is a micro-framework built on the WSGI interface.
    It is well-suited for smaller applications and follows a minimalist philosophy
    in selecting components that are used.\cite{flask} Most additional functionality is provided by
    the community and distributed as external packages.

    One of the main downsides of Flask is that it does not integrate well enough with the ASGI
    interface which is necessary for proper handling of Server-Client path of communication.
    Moreover, strongly relying on external packages can pose potential security risks.
\end{itemize}

Of the three frameworks Django is the most suitable one.
Most of the application logic will be handled by the backend, heavily utilizing
Django's ORM for most database tasks. On top of that, a JSON-based API can be implemented
using `django-rest-framework`, simplifying communication with the frontend.

\subsection{Database}
Below is the comparison of the databases that Django framework supports.
It is worth to mention, that two other databases can be used as well - Oracle and MySQL.
However, Oracle is ruled out due to its commercial licence, and MySQL is not considered, because
MariaDB is fully compatible with it, while providing multiple enhancements.

\begin{itemize}
    \item \textbf{SQLite} \\
    'SQLite is an embedded SQL database engine.
    Unlike most other SQL databases, SQLite does not have a separate
    server process. SQLite reads and writes directly to ordinary disk
    files.'\cite{sqlite}. As the result of SQLite's design it is suitable
    in situations, where a simple storage is needed and write operations are limited.
    It is lightweight, but is struggles in high workload situations; many issues can arise
    in architectures with a sharded database placed on multiple servers.

    \item \textbf{PostgreSQL} \\
    PostgreSQL is a traditional object-relational database that is almost fully compatible with the SQL standard
    and is a de-facto standard in most modern application. It offers a lot of supplementary features,
    such as complex data types, proper replication and logging, full text search and many others.
    In addition to that, PostgreSQL provides many extensions which can tailor the database to any specific application.
    \cite{postgres}
    Django has the best support for it, adding a lot of wrappers for Postgre's custom logic.\cite{django_postgres}

    \item \textbf{MariaDB} \\
    MariaDB is a fork of MySQL which adds several advanced features and performance optimizations.
    One of the prominent aspects of this database are its pluggable storage engine architecture,
    which allows you to choose different engine per table for the needed workload.\cite{mariadb}
    If set up right, it can also be lightweight and use less system resources than PostgreSQL.
    However, it is not fully in line with the SQL standard -
    e.g. limited ALTER statements and GROUP BY handling\cite{dbfunctions}.
    And as a consequence of its lesser acceptance\cite{dbrank},
    the community support for the non-MySQL parts of the database is not as broad.
\end{itemize}
Three main points secured PostgreSQL as the database of choice:
\begin{enumerate}
    \item More advanced full text search functionality (discussed in ...) compared to MariaDB.
    \item Integrated Django wrappers around PostgreSQL, which greatly reduce the amount of handwritten SQL.
    \item Superior syntax, command-line interface, and error handling/messages.
\end{enumerate}


\section{Frontend}
Contrary to popular belief, JavaScript is not the only language, in which the user interface part
of the service can be written. Rust, Python and even C could be used to create a working UI.
However, it comes with a lot of drawbacks - they are not directly supported by the browsers, which
means that the code has to be complied to WebAssembly. This adds
additional overhead to the development cycle, introduces new toolchains that add another level of
complexity and more often than not results in bigger bundle(hence, download) sizes.
That is why the Frontend of the application is written in JavaScript and only JS frameworks are
compared.

- React.
- Svelte
- Vue


\section{Audio Transfer}
Audio playback can be tackled in numerous ways:

\begin{itemize}
    \item \textbf{Basic Download}\\
    The audio file is downloaded in its entirety before playback begins.
    Once the download is complete, the user can listen to the file offline.
    This method typically requires significant storage space and time to download,
    especially for larger audio files.

    \item \textbf{Progressive Download}\\
    The audio file begins to play after a portion of the file
    has been downloaded. As the playback continues, more of the file is downloaded
    in the background. This method allows for quicker access to the content
    compared to basic downloading, but still requires enough data to be buffered at the start or during seeking.

    \item \textbf{Streaming}\\
    Audio is transmitted over the internet in real-time, without needing
    to be downloaded. The user can start listening almost immediately while the audio is being
    sent from a remote server. This method doesn’t require local storage and is
    ideal for accessing content on demand, but it depends on a stable internet connection.
    Additionally, modern streaming protocols support adaptive streaming, allowing the audio file
    to be delivered in multiple representations. Different bitrates and codecs can be
    selected based on the network conditions or device capabilities, providing an optimized experience.
    Furthermore, seeking can be more accurate because streaming protocols divide the data into
    smaller, discrete chunks, allowing for quicker access to specific points in the audio.

    \item \textbf{Peer to Peer}\\
    In P2P audio streaming, audio data is shared directly between users'
    devices, rather than being served from a central server.
    Each user acts as both a client and a server, contributing to and consuming
    data. This method can reduce server load and improve access speed,
    but it relies heavily on user participation and network conditions.
\end{itemize}

Although basic and progressive download methods are much simpler in implementation,
streaming has many invaluable benefits, allowing for smooth playback in different
conditions and better audio representation techniques. P2P is also not suitable
in the current case, as the files must be on users' machines, which can lead
to various problems — from delays for clients located far away from the source of the audio
to problematic enforcement of possible DRM (anti-piracy) protection.


\section{Authentication}
There are many different methods of authentication available, but only the ones suitable for
WEB applications are considered below:
\begin{itemize}
    \item \textbf{Basic Authentication} \\
    Basic Authentication works by sending a username and password with each request,
    typically encoded in base64.\cite{basic_auth} It is simple to configure, and it can work well for
    e.g. communication between internal services. However, it incorporates credentials in every request,
    making it prone to security risks in client-server systems, if not used over HTTPS.
    Moreover, It lacks session management, limiting scalability.

    \item \textbf{Session Authentication} \\
    Session authentication creates a session after the user logs in, with session
    data stored on the server and the client storing a session ID in a cookie.
    It makes authentication management centralized, which can enhance security compared to Basic Authentication.
    However, it can be vulnerable to session hijacking if cookies are not properly protected
    and can greatly increase the load on the database.\cite{session_auth}

    \item \textbf{JWT (JSON Web Token)} \\
    JWT is a compact, URL-safe method of representing claims between two parties.\cite{jwt}
    It is an example of stateless authentication where token has all the needed information for user authentication.
    It can also carry additional custom payload which, for instance, can be utilized for role management.
    They provide a flexible and scalable way to implement secure authentication.
    However, if not properly managed (e.g., using long expiration times), they can become security risks,
    as compromised tokens may be used for extended periods.

    \item \textbf{OAuth 2.0} \\
    OAuth 2.0 is an authorization framework that allows third-party applications to access resources
    on behalf of the user, without exposing user credentials.\cite{oauth2} It requires the user to have an account
    with a company that owns a resource server(e.g. Google, Facebook\ldots). This is a proper mean of
    authorization, however, it must be used in congestion with other regular methods.
\end{itemize}

JWT tokens were chosen as the main method of authentication. They are easy to set up, behave well when the
application scales horizontally and, most importantly, do not use the database to manage authentication details.


\section{Server-Client Communication}
As it was pointed out before, the communication in the application is going to be two-way.
Because this is a WEB-application, techniques such as Webhooks, gRPC, Pub/Sub and
others that are not directly supported by browsers will not be discussed. Traditional polling is not discussed due
to the performance limitations and its inefficiency. P2P techniques(e.g. WebRTC DataChannels) will not be listed,
because the architecture of the application is client-server, not peer-to-peer.

- Long-Polling
- Server Sent Events
- Websockets
- WebWorkers Push API
